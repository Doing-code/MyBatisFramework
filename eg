
从设计结构上了解工厂模式对具体功能结构的封装，屏蔽过程细节，限定上下文关系，把对外的使用减少耦合。

使用 SqlSessionFactory 的工厂实现类包装了 SqlSession 的标准定义实现类，并由 SqlSession 完成对映射器对象的注册和使用。

重要知识点：映射器、代理类、注册机、接口标准、工厂模式、上下文。
------------------------------------------------------------------------------------------------------------------------

只有非常清楚的知道这个代理、封装、解析和返回结果的过程才能更好的完成整个框架的实现。

SqlSessionFactoryBuilder 的引入包装了整个执行过程，包括：XML 文件的解析、Configuration 配置类的处理，让 DefaultSqlSession 可以更加灵活的拿到对应的信息，获取 Mapper 和 SQL 语句。

工厂模式、建造者模式、代理模式的使用，这些技巧都可以让整个工程变得易于维护和易于迭代。
------------------------------------------------------------------------------------------------------------------------

整个 Mybatis 的操作都是使用 Configuration 配置项进行串联流程，所以所有内容都会在 Configuration 中进行链接。

以解析 XML 配置解析为入口，添加数据源的整合和包装，引出事务工厂对 JDBC 事务的处理，并加载到环境配置中进行使用。

通过数据源的引入就可以在 DefaultSqlSession 中从 Configuration 配置引入环境信息，把对应的 SQL 语句提交给 JDBC 进行处理并简单封装结果数据。
------------------------------------------------------------------------------------------------------------------------

连接池的实现重点包括：synchronized 加锁、创建连接、活跃数量控制、休眠等待时长，抛异常逻辑等

只有动手自己实现一遍数据源连接池才能更好的理解池化技术的落地方案，也能为以后做此类功能时，有一个可落地的具体方案。
------------------------------------------------------------------------------------------------------------------------

【策略+模板】
为什么要定义SQL执行器？
 - 解耦。
 - 抽象出一套标准，功能迭代中能方便的扩展
执行器贯穿始终
执行器中又包括了对 JDBC 处理的拆解，链接、准备语句、封装参数、处理结果，所有的这些过程经过解耦后的类和方法，就都可以在以后的功能迭代中非常方便的完成扩展了。
------------------------------------------------------------------------------------------------------------------------

【对象工厂创建对象 + 反射工具包赋值】
使用了大量的 JDK 所提供的关于反射一些处理操作，也包括可以获取一个 Class 类中的属性、字段、方法的信息。那么再有了这些信息以后就可以按照功能流程进行解耦，把属性、反射、包装，都依次拆分出来，并按照设计原则，逐步包装让外接更少的知道内部的处理。
ObjectFactory：【对象工厂】Mybatis每次在创建Mapper映射结果对象实例的时候，就会使用ObjectFactory来完成对象实例。
如果通过继承DefaultObjectFactory类的方法来实现了自定义的ObjectFactory，那么就得使用Mybatis提供的标签来注册自定义的ObjectFactory。
<objectFactory type="org.mybatis.example.ExampleObjectFactory">
  // <property name="someProperty" value="100"/>
</objectFactory>
当我们配置了相关的对象工程（objectFactory标签），则会调用我们自定义的对象工厂进行处理，相当于做了拦截。
【每次 MyBatis 创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成实例化工作。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认无参构造方法，要么通过存在的参数映射来调用带有参数的构造方法。 如果想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现】

------------------------------------------------------------------------------------------------------------------------
通过设计原则进行拆分和解耦，运用不用的类来承担不同的职责，完成整个功能的实现。这包括：映射构建器、语句构建器、源码构建器的综合使用，以及对应的引用；脚本语言驱动和脚本构建器解析，处理我们的 XML 中的 SQL 语句。

------------------------------------------------------------------------------------------------------------------------
所包含的分包结构。比如：构建、绑定、映射、反射、执行、类型、事务、数据源等等

关于参数类型的策略化设计，通过策略解耦，模板定义流程，让我们整个参数设置变得更加清晰，也就不需要硬编码了